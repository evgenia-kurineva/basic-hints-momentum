#### Советы по выполнению задания
0. [Организация работы](#0-организация-работы)
1. [Часы и календарь](#1-часы-и-календарь)
2. [Приветствие](#2-приветствие)
3. [Слайдер изображений](#3-слайдер-изображений) 
4. [Виджет погоды](#4-виджет-погоды)
5. [Виджет "цитата дня"](#5-виджет-"цитата-дня")
6. [Аудиоплеер](#6-аудиоплеер)
7. [Продвинутый аудиоплеер](#7-продвинутый-аудиоплеер)
8. [Перевод приложения](#8-перевод-приложения)
9. [Получение фонового изображения от API](#9-получение-фонового-изображения-от-API)
10. [Настройки приложения](#10-Настройки-приложения)



## 0. Организация работы

1. [Изучение ТЗ](#1-изучение-тз)
2. [Декомпозиция задания](#2-декомпозиция-задания)
3. [Тайминг времени](#3-тайминг-времени)
4. [Вёрстка](#4-вёрстка)

### 1. Изучение ТЗ
Изучение техзадания - важный этап работы над проектом. Вам необходимо чётко понимать как должно выглядеть и работать созданное вами приложение. С изучения ТЗ начинается работа над любым проектом, будь это реальная разработка или учебный таск. Лишние пять минут изучения ТЗ могут сэкономить несколько часов кодинга, когда из-за неправильно понятого ТЗ нужно будет переделывать уже реализованный функционал.

Демо приложения помогает визуализировать требования, но не заменяет изучение ТЗ.  
Если после внимательного изучения ТЗ остались вопросы или сомнения, задать их можно в дискорде в канале с названием таска, или в [документе для вопросов](https://docs.google.com/spreadsheets/d/1dMDLBC4-1XPaVMehZB6DqetToXZhq4x0PiZtj-jvLRc/edit#gid=1153986630), или непосредственно автору таска.

**Не приступайте к работе без чёткого понимания, что именно требуется сделать и какой результат от вас ожидают**.

### 2. Декомпозиция задания
Декомпозиция - разделение целого на части. Когда вы поняли задачу в целом, разбейте её на небольшие подзадачи и выполняйте последовательно каждую их них. Даже огромный объём работы состоит из конечного числа отдельных частей, с каждой из которых вы можете справиться. Продумайте план выполнения задания, взаимосвязь его отдельных элементов. На этом этапе очень пригодится понимание задания в целом, которого вы добились, выполняя предыдущий пункт.

В процессе декомпозиции поможет то, что требования к заданию разбиты на пункты. Но и эти пункты можно разбивать на отдельные подпункты, чтобы каждый из них решался всего несколькими или даже только одной строкой кода. Как это сделать будет показано в советах по коду отдельных функциональных блоков.

### 3. Тайминг времени
Как разработчик определяет сколько времени у него уйдёт на выполнение задания? Сравнивая предстоящее задание с предыдущими выполненными им тасками, и временем, которое заняла работа над ними. У начинающего разработчика такого эталона для сравнения нет, его нужно создавать, и учебные задания для этой цели подходят очень хорошо.

В программе курса для таска momentum указано ориентировочное время - 20 часов. Основываясь на опыте выполнения подобных заданий студентами предыдущих наборов, мы предполагаем, что этого времени будет достаточно начинающему разработчику для выполнение обязательных требований таска. Но скорость разработки у каждого индивидуальная, и с накоплением опыта она будет меняться. 

Если вы затрудняетесь с выбором программы для учёта времени, присмотритесь к [trello](https://netology.ru/blog/trello), к которому можно бесплатно подключить расширение [Activity](https://texterra.ru/blog/prokachay-svoy-trello-rasshireniy-i-integratsiy-dlya-produktivnoy-raboty.html)  

Учёт времени поможет вам организовать свою работу, сократит непродуктивные затраты времени, выявит моменты, когда время было потрачено напрасно.

Например, на этом [скрине](../images/trello.jpg) видно, что слишком много времени ушло на создание репозитория с проектом (нужно совершенствовать навыки работы с Git), больше двух часов потребовалось для реализации переключателя.

Чтобы не тратить время напрасно, полезно использовать правило 30 минут - если за полчаса не удаётся найти решение самостоятельно, обратитесь за помощью - задайте вопрос в чате.

Ещё одно преимущество использования программ для учёта времени - возможность отслеживания индивидуального прогресса. С накоплением опыта вы не только сможете выполнять более сложные задания, но и существенно ускорите решение более простых, уже известных вам задач.

### 4. Вёрстка
В описании задания есть ссылка на [файлы с вёрсткой](https://github.com/rolling-scopes-school/stage1-tasks/tree/momentum). Чтобы скачать их себе на компьютер, нажмите на зелёную кнопку `Code` и выберите пункт `Download ZIP`

Вы можете:
- использовать предложенные файлы
- вносить в них правки
- полностью их изменить или вообще не использовать.

Используя предложенные файлы вы существенно сократите время работы над проектом, сможете сосредоточиться на js-коде. Но при этом вам необходимо будет разбираться с чужим html-кодом (какой элемент за что отвечает), мириться с чужими названиями классов и стилями.

Самостоятельно сверстать приложение немного дольше, зато самостоятельно написанный код вы будете знать в совершенстве, названия классов и стили будут именно такими, какими вы их хотите видеть.

В любом случае, вёрстку нужно будет дополнить продвинутым аудиоплеером, настройками, дополнительным функционалом. Сверстать их можно на основе аналогичного функционала [приложения momentum](https://chrome.google.com/webstore/detail/momentum/laookkfknpbbblfpciffpaejjkokdgca?hl=ru) интернет-магазина Chrome - прототипа приложения, которое мы создаём.

## 1. Часы и календарь

#### Время выводится в 24-часовом формате

Делим данный пункт требований задания на подзадачи. Нам нужно:
1) найти на странице элемент, внутри которого выводится время
2) научиться отображать внутри этого элемента текст
3) получить текущее время в часах, минутах и секундах
4) написать функцию, которая будет выводить текущее время внутри указанного элемента

#### Методы поиска элементов
Из всех перечисленных в учебнике [методов поиска элементов](https://learn.javascript.ru/searching-elements-dom) в 90% случаев достаточно использовать метод `querySelector`. 

**Пример**  
В html-файле есть элемент с классом `time`.  
Находим элемент с классом `time` и записываем его в переменную `time`:
```js
const time = document.querySelector('.time');
```
Выведем найденный элемент в консоль, чтобы убедиться, что наш код работает:
```js
console.log(time);
```
**Обратите внимание** 
- все переменные, соответствующие элементам, которые есть в коде страницы, объявляются при помощи ключевого слова `const`
- названия переменных - существительные
- отладочная информация, к которой относится `console.log`, по окончанию работы над проектом удаляется

#### Вывод текстовых данных на страницу
Чтобы отобразить внутри элемента текст, используется метод `textContent`
```js
time.textContent = "Text";
```
#### Получаем текущее время
JavaScript позволяет легко получить текущие дату и время. Выполните в консоли код:
```js
const date = new Date();
console.log(date);
```
Чтобы из строки с датой и временем получить только время, удобно использовать метод [toLocaleTimeString()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date/toLocaleTimeString)

Выполните в консоли код:
```js
const date = new Date();
const currentTime = date.toLocaleTimeString();
console.log(currentTime);
```
#### Функция showTime()
Вы уже можете отобразить на странице текущее время. Этот код необходимо обернуть в функцию.

Методы поиска элементов в функции включать не нужно: все найденные элементы вместе с присвоенными им переменными оставляем в начале кода.

**Обратите внимание**, если названия переменных — существительные, то названия функций — глаголы.

Создайте функцию `showTime()` отображающую на странице текущее время
```js
function showTime() {
  // здесь ваш код
}
showTime();
```
Если вы всё сделали правильно, при вызове функции `showTime()` на странице выводится текущее время.

Обратите внимание, функция получилась очень небольшой и содержит всего три строчки. Небольшой размер функции это хорошо: чем короче код, тем меньше в нём ошибок.

Впрочем, количество строчек не имеет решающего значения при определении того, какой участок кода выносить в отдельную функцию. При создании функций руководствуйтесь общим правилом: **одна функция — одна задача**.

#### Время обновляется каждую секунду (часы идут)
Если вы обновите страницу приложения, время обновится. Это происходит потому, что при обновлении страницы перезапускается js-код, в том числе функция `showTime()`, которая отвечает за отображение текущего времени. Для обновления функции каждую секунду используем [рекурсивный setTimeout](https://learn.javascript.ru/settimeout-setinterval#rekursivnyy-settimeout) — вызов функции внутри неё самой с интервалом в 1 секунду или 1000 миллисекунд.
```js
function showTime() {
  // здесь ваш код
  setTimeout(showTime, 1000);
}
showTime();
```
#### Выводится день недели, дата, месяц
Требование очень похожее отображение точного времени, для его выполнения используем те же шаги:
1) находим на странице элемент, внутри которого выводится дата
2) получаем текущую дату в указанном формате
3) создаём функцию, которая будет отображать дату внутри указанного элемента
4) при изменении даты обновляем её отображение на страницы

Первый пункт сложности вызывать не должен, методы поиска элементов рассматривали выше.

#### Получаем текущую дату
Для получения даты используем метод [toLocaleDateString()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date/toLocaleDateString).

У данного метода два аргумента: локаль - язык отображения даты, например 'ru-RU', 'en-US', 'en-Br' и объект options в котором перечисляются какие параметры даты и в каком представлении нужно отображать. Например:
```js
const date = new Date();
const options = {month: 'long', day: 'numeric', hour: 'numeric', minute: 'numeric', timeZone: 'UTC'};
const currentDate = date.toLocaleDateString('de-De', options);
console.log(currentDate);
```
В консоль выводится дата и время на немецком языке по Всемирному координированному времени. В данном задании указывать таймзону нет необходимости, но в будущем возможно вам захочется создать приложение, отображающее время для разных точек планеты или сравнивающее время в разных странах.

#### Обновляем дату
В 12 ночи дату нужно будет обновить. Как это сделать? Решение — поместить вызов функции `showDate()` внутрь наших часов — функции `showTime()`. Благодаря рекурсивному `setTimeout` функция `showTime()` обновляется каждую секунду, соответственно, каждую секунду будет обновляться и `showDate()`.

#### Ключевые навыки, которые вы приобрели:
- методы поиска элементов
- вывод текстовых данных на страницу
- дата и время
- рекурсивный setTimeout

Если все пункты выполнили верно, у вас получилось полноценное js-приложение, отображающее дату и время. Его можно использовать как стартовую страницу или показать тем людям, которые вас поддерживают, как пример первого самостоятельно выполненного таска по JavaScript. Поздравляю.

## 2. Приветствие

#### Текст приветствия изменяется в зависимости от времени суток
Декомпозиция пункта требований:
1. Найти элемент, внутри которого выводится текст приветствия
2. Определить текущее время в часах
3. Определить текущее время суток
4. Сгенерировать приветствие в зависимости от времени суток
5. Создать функцию `showGreeting()`, которая будет отображать приветствие внутри указанного элемента
6. Обеспечить обновление созданной функции

Реализация пункта требований:
1. Методы поиска элемента мы уже рассмотрели
2. Текущее время в часах возвращает метод `getHours()`
```js
const date = new Date();
const hours = date.getHours();
console.log(hours);
```
3. Функцию `getTimeOfDay()`, возвращающую время суток (morning, day, evening, night) в зависимости от текущего времени в часах вам предстоит написать самостоятельно.  
Написать такую функцию можно разными способами: используя опретор `if... else`, или оператор `switch`, или создать массив с названиями времён суток и в зависимости от того, какое целое число получается при делении текущего времени суток на 6, возвращать соответствующий элемент массива.  
Если сомневаетесь какой подход выбрать, отталкивайтесь от того, что преимущество у наиболее простых, лакончиных и понятных решений. При этом не стремитесь к преждевременной оптимизации: можно использовать любой подход, решающий поставленную задачу.

4. Для генерации приветствия удобно использовать [шаблонные строки](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Template_literals)  
Шаблонная строка выглядит почти так же как обычная строка с небольшими отличиями:  
1. шаблонная строка берётся в косые кавычки  
2. внутрь шаблонной строки можно помещать переменные, взяв их в фигурные скобки и указав знак доллара перед первой скобкой.

**Пример**
```js
const timeOfDay = getTimeOfDay();
const greetingText = `Good ${timeOfDay}`;
```
5. Шаблонная строка возвращает обычный текст, который можно отобразить внутри указанного элемента при помощи метода `textContent()`
6. Обновление приветствия происходит так же, как обновление даты - вызов функции `showGreeting()` помещаем внутрь функции `showTime()` 

#### Пользователь может ввести своё имя
Если вы воспользовались предложенной вёрсткой, данное требование в ней уже выполняется, никаких дополнительных усилий для его реализации предпринимать не нужно. 

В рамках работы над данным пунктом требований было бы полезно познакомиться с интересным и разнообразным элементом [&lt;input&gt;](https://developer.mozilla.org/ru/docs/Web/HTML/Element/Input), разобраться с особенностями получения и изменения его значения.

Элемент `<input>` имеет больше 20 разных типов. Каждый из них предназначен для решения определённой задачи. В приложении используется пожалуй наиболее распространённый `<input>` с типом текст: `type="text"`. Но есть и другие типы элемента `<input>`, никак не связанные с вводом текста. Например: 
- `color` - палитра для выбора цвета;
- `file` - загрузка файлов;
- `radio` - кнопка-переключатель;
- `range` - ползунок для изменения значения.

Так как не все элементы `<input>` связаны с текстом, уже известное нам свойство `textContent` для элемента `<input>` не работает. Вместо него используется удобное свойство `input.value` при помощи которого можно получить и указать значение `<input>`.

#### При перезагрузке страницы приложения имя пользователя сохраняется
Для сохранения имени пользователя используем хранилище браузера - `local storage`.

Работа с `local storage` состоит из двух частей. 
1) перед перезагрузкой или закрытием страницы (событие `beforeunload`) данные нужно сохранить
```js
function setLocalStorage() {
  localStorage.setItem('name', name.value);
}
window.addEventListener('beforeunload', setLocalStorage)
```
2) перед загрузкой страницы (событие `load`) данные нужно восстановить и отобразить
```js
function getLocalStorage() {
  if(localStorage.getItem('name')) {
    name.value = localStorage.getItem('name');
  }
}
window.addEventListener('load', getLocalStorage)
```
Пояснения к коду:
- `window` - объект окна браузера, с ним связана загрузка и перезагрузка страницы  
- `addEventListener` - метод, который отлавливает событие элемента и выполняет переданную функцию
- `localStorage.setItem` - метод сохраняющий данные в `localStorage`. Два параметра метода: имя значения, которое сохраняется и само значение, которое сохраняется 
- `localStorage.getItem` - метод получающий данные из `localStorage`. Параметр метода - имя, под которым сохраняется значение.

Чтобы увидеть сохранённые в браузере данные `localStorage`, на странице приложения нажмите клавишу F12, на панели `devTools` вверху выберите пункт `Application`, на боковой панели пункт `Local Storage` и ссылку на страницу приложения.

Обратите внимание: данные в `localStorage` сохраняются в текстовом формате, например, вместо `true`, `false`, `localStorage` вернёт `"true"` и `"false"`.

#### Метод addEventListener()
В предыдущем разделе, чтобы выполнить код только после того, как изображение загрузилось, мы использовали метод `addEventListener()`. Это важный метод регистрации событий. 

Событие – это сигнал от браузера о том, что что-то произошло.  
Существует много видов событий. Перечислим некоторые из них (запоминать события не нужно).

**События мыши**:
- `click` – клик
- `contextmenu` – клик правой кнопкой мыши
- `dbclick` – двойной клик
- `mouseover` – навели курсор
- `mouseout` – убрали курсор
- `mousedown` и `mouseup` – кнопку мыши нажали или отжали
- `mousemove` – движение мыши

**События клавиатуры**:
- `keydown` – кнопка нажата
- `keyup` – кнопка отжата
- `keypress` – кнопка удерживается

**События на элементах управления**:
- `focus` – элемент в фокусе, например, пользователь нажимает на input или в текстовое поле вводит текст
- `blur` – убрали мышку из фокуса
- `reset` – форма очищена
- `submit` – форма отправлена

И все эти события можно отлавливать.

Метод `addEventListener()` отлавливает событие элемента и выполняет переданную функцию.
Его синтаксис:
```js
element.addEventListener('click', () => {
  // code
});
```
- `element` – элемент на котором отлавливаем события;
- `addEventListener()` – метод отлова событий;
- `click` – какое именно событие отлавливаем (в данном случае 'клик');
- `() => {}` – функция, которая будет выполнена в тот момент, когда событие произойдёт.

Функцию, которая выполняется при наступлении события, лучше создавать отдельно, а внутри метода `addEventListener()` только указывать какая именно функция будет выполняться при наступлении данного события. 
```js
element.addEventListener('click', function);
```
Обратите внимание: внутри `addEventListener()` только указываем функцию `function`, а не вызываем её `function()`

#### Ключевые навыки, которые вы приобрели:
- использование шаблонных строк
- особенности элемента `<input>`
- работа с `localStorage`
- метод `addEventListener()`

## 3. Слайдер изображений

#### Фоновое изображение выбирается из расположенной на GitHub коллекции изображений
JavaScript позволяет указывать стиль элемента. Для этого используя методы поиска элементов находим на странице элемент `body` и указываем его стиль.
```js
body.style.backgroundImage = "url('https://raw.githubusercontent.com/rolling-scopes-school/stage1-tasks/assets/images/evening/18.jpg')";
```
Обратите внимание:
- одинарные кавычки вложены в двойные кавычки;
- свойство `background-image` в js записывается через camelCase `backgroundImage`;

#### Ссылка на фоновое изображение формируется с учётом времени суток и случайного номера изображения
Функция `getTimeOfDay()`, возвращающая время суток, у нас уже есть.  
Также необходимо написать функцию `getRandomNum()`, возвращающую рандомное число от 1 до 20 включительно.  
Для решения этой задачи подойдёт метод [Math.random()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Math/random) - по ссылке нужно найти подходящий пример, решающий поставленную задачу.

Если мы можем получить время суток и рандомное число, можно создать функцию `setBg()`. В ней определите две переменные
- timeOfDay - текущее время суток;
- bgNum - порядковый номер фонового изображения.  
Переменная bgNum формируется на основе рандомного числа, дополняя его слева нулями, если число однозначное. Для этой цели можно использовать метод [padStart()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/padStart).  

Затем по предложенному в задании примеру ссылки на изображение `https://raw.githubusercontent.com/rolling-scopes-school/stage1-tasks/assets/images/evening/18.jpg` используя шаблонную строку сформируйте ссылку на случайное изображение, соответствующее текущему времени суток, и указываете его фоном элемента `body`.

Вызываете функцию `setBg()` и, если всё сделали правильно, дефолтное фоновое изображение должно измениться на полученное из интернета.

#### Изображения можно перелистывать кликами по стрелкам, расположенным по бокам экрана
Вам необходимо написать две функции:
- `getSlideNext()` - увеличивает рандомное число на 1 пока результат не станет равным 20. Если результат сложения равен 20, следующему за ним числу присваиваете значение 1.
- `getSlidePrev()` - уменьшаете рандомное число на единицу, пока оно больше 1. Если результат вычитания равен 1, следующему за ним числу присваиваете значение 20.
Внутри этих функций вызываете функцию `setBg()`, обновляющую фоновое изображение.

Чтобы предложенная логика работала, переменная `randomNum` должна находиться в глобальной области видимости, там же, где в вашем коде находятся методы поиска элементов.
```js
let randomNum;
```
Функция `getRandomNum()` присваивает значение `randomNum`. Не возвращает, а присваивает, то есть пишет: `randomNum = // здесь ваш код...`

Функции `getSlideNext()` и `getSlidePrev()` соответственно увеличивают или уменьшают глобальную переменную `randomNum` на единицу.

Функции `getSlideNext()` и `getSlidePrev()` вызываем при кликах по стрелкам `slideNext` и `slidePrev`. 
```js
slideNext.addEventListener('click', getSlideNext)
```

#### Плавная смена фоновых изображений
Чтобы избежать моментов, когда фоновое изображение ещё не загрузилось, но уже используется как фоновое, необходимо указывать его фоном страницы только после полной загрузки. Для этого через js создаём изображение, указываем его адрес, дожидаемся загрузки изображения для чего используем событие `load` и только потом указываем ссылку на изображение в качестве фона страницы. Модифицируйте функцию `setBg()`
```js
function setBg() {  
  const img = new Image();
  img.src = // здесь ваш код 
  img.onload = () => {      
    body.style.backgroundImage = // здесь тоже ваш код
  }; 
}
```
**Обратите внимание** в примере выше вместо
```js
img.addEventListener('load', () {
  body.style.backgroundImage = ...
})
```
используется упрощённый вариант [регистрации обработчика событий](https://developer.mozilla.org/ru/docs/Web/API/EventTarget/addEventListener#older_way_to_register_event_listeners)
```js
img.onload = () => {      
  body.style.backgroundImage = ...
};
```
В разработке могут встречаться и использоваться оба варианта регистрации обработчика событий, при этом метод `addEventListener()` является более новым и имеет дополнительные возможности.

После установки фонового изображения через js желательно отключить фоновое изображение в css-стилях, иначе при загрузке страницы сначала будет появляться фон, указанный в css, а сразу за ним фон, указанный через js.  

#### Ключевые навыки, которые вы приобрели:
- добавление стилей средствами js
- использование события `load` - первый шаг к пониманию асинхронности
- добавление слушателя через on&lt;событие&gt;
- создали слайдер изображений

## 4. Виджет погоды

Приводится пример создания приложения с прогнозом погоды для указанного пользователем города.  

#### Регистрация в OpenWeatherMap API
Данные о погоде предоставляют API погоды. 

Регистрируемся в OpenWeatherMap API [https://home.openweathermap.org/users/sign_up](https://home.openweathermap.org/users/sign_up)

На указанную при регистрации почту приходит письмо с предложением подтвердить e-mail. Подтверждаем.

На странице [https://home.openweathermap.org/api_keys](https://home.openweathermap.org/api_keys) видим свой API key

#### Получение информации о погоде
Для получения информации о погоде создаём ссылку
`https://api.openweathermap.org/data/2.5/weather?q=Минск&lang=ru&appid=08f2a575dda978b9c539199e54df03b0&units=metric`

Здесь:
- `Минск` - название города, можно указывать на русском или на английском языке
- `08f2a575dda978b9c539199e54df03b0` - API key полученный при регистрации 
- `lang=ru` - язык отображения описания погоды (можно указать `lang=en`)
- `units=metric` - температура в градусах Цельсия (можно указать `units=imperial` для отображения температуры в градусах Фаренгейта)

Дальше используйте только ссылку со своим собственным API key. Если использовать ссылку, пример которой приводится в задании, очень быстро исчерпается лимит API, и она перестанет работать.

#### Просмотр информации о погоде
Переходим по созданной ссылке со своим собственным API key. На странице отображается информация о погоде. Для удобного её отображения установите расширение [**JSONView**](https://chrome.google.com/webstore/detail/jsonview/chklaanhfefbnpoihckbnefhakgolnmc?hl=ru)

По ссылке отображается объект с погодой. Некоторые свойства данного объекта:
- `.weather[0].id` - id иконки погоды
- `.weather[0].description` - описание погоды
- `.main.temp` - температура

#### Вывод информации о погоде в консоль
Получим информацию о погоде. Пока выведем её в консоль.

Для этого создадим асинхронную функцию:
```js
async function getWeather() {  
  const url = `https://api.openweathermap.org/data/2.5/weather?q=Минск&lang=ru&appid=08f2a575dda978b9c539199e54df03b0&units=metric`;
  const res = await fetch(url);
  const data = await res.json(); 
  console.log(data.weather[0].id, data.weather[0].description, data.main.temp);
}
getWeather()
```
В функции `getWeather()` мы получили объект с погодой `data` и вывели в консоль интересующие нас свойства.

Ссылка в косых кавычках - шаблонная строка. Позже нам понадобится возможность добавить в шаблонную строку значение переменной - название указанного пользователем города.

Функция `getWeather()` не большая, не сложная. Единственное её неудобство - все полученные данные доступны исключительно внутри самой функции, получить их в основном коде невозможно. Асинхронные функции связаны с получением ответа от сервера и выполняются после того, как отработал весь код приложения. Это необходимо для того, чтобы весь код приложения не ждал пока асинхронная функция вернёт или не вернёт результат. 

#### Вывод информации о погоде на страницу
Выведем полученные данные на страницу
В `index.html` создадим элементы для отображения иконки погоды, температуры и описания погоды:
```html
<i class="weather-icon owf"></i>
<div class="temperature"></div>
<div class="weather-description"></div>
```
В js-коде найдём эти элементы:
```js
const weatherIcon = document.querySelector('.weather-icon');
const temperature = document.querySelector('.temperature');
const weatherDescription = document.querySelector('.weather-description');
```
И внутри функции `getWeather()` укажем их содержание:
```js
async function getWeather() {
  const url = `https://api.openweathermap.org/data/2.5/weather?q=Минск&lang=ru&appid=08f2a575dda978b9c539199e54df03b0&units=metric`;
  const res = await fetch(url);
  const data = await res.json();

  weatherIcon.classList.add(`owf-${data.weather[0].id}`);
  temperature.textContent = `${data.main.temp}°C`;
  weatherDescription.textContent = data.weather[0].description;
}
```
Блокам с температурой и описанием погоды мы указали `textContent`, иконке погоды добавили класс.

#### Отображение иконки погоды
Иконки погоды для Open Weather Map API находятся здесь https://websygen.github.io/owfont/
Скачиваем, распаковываем, папку `fonts` помещаем в папку с проектом, файл `owfont-regular.css` из скачанной папки `css` помещаем в папку `css` нашего проекта, подключаем в `index.html`  перед подключением `style.css`. 
```html
<link rel="stylesheet" href="css/owfont-regular.css">
```
Если вы используете дефолтную вёрстку, шрифт и стили иконок погоды в ней уже подключены.

### Получаем погоду для определённого города
Когда пользователь ввёл название города в предназначенный для этого `input` с классом `city` нам необходимо получить информацию о том, какой город он указал.
Для этого находим соответствующий элемент и назначаем ему слушатель события `change`, который сработает если пользователь нажмёт клавишу `Enter` или фокус уйдёт из поля `input`. Когда на `input` произойдёт событие `change`, вызываем функцию `getWeather()`, изменив в ней `url`:
```js
const url = `https://api.openweathermap.org/data/2.5/weather?q=${city.value}&lang=ru&appid=08f2a575dda978b9c539199e54df03b0&units=metric`;
```
Теперь у нас отображается погода того города, который указан в блоке `city`.

В функции `getWeather()` перед добавлением иконке погоды дополнительного класса укажем строку
```js
weatherIcon.className = 'weather-icon owf';
```
Этой строкой мы удаляем все лишние классы перед добавлением нового, чтобы иконка погоды обновлялась корректно.

[Код приложения](https://github.com/rolling-scopes-school/stage1-tasks/tree/gh-pages/weather)  
[Demo](https://rolling-scopes-school.github.io/stage1-tasks/weather/)

#### Ключевые навыки, которые вы приобрели:
- получение данных от API
- работа с асинхронными запросами
- создали приложение погоды

## 5. Виджет "цитата дня"

Виджет "цитата дня", как и виджет погоды, предполагает использование асинхронных запросов к API.

При использовании данных API необходимо учитывать, что они могут перестать работать, в результате неработоспособным станут и созданные на их основе приложения.  
Например, почти у половины лучших работ позапрошлого набора виджет "цитата дня" сейчас, спустя год, не работает. Все приведённые в материалах к заданию API с русскоязычными цитатами и некоторые API с англоязычными цитатами спустя год оказались неработоспособными. 

Возможным решением может быть создание собственного JSON-файла с цитатами и их авторами.

Пример файла `data.json`:

```json
[
  {
    "text": "Пишите код так, как будто сопровождать его будет склонный к насилию психопат, который знает, где вы живете",
    "author": "Стив Макконнелл"
  },
  {
    "text": "Сложность программы растет до тех пор, пока не превысит способности программиста",
    "author": "Артур Блох. Законы Мэрфи"
  },
    {
    "text": "Ходить по воде и разрабатывать программы, следуя ТЗ, очень просто… если они заморожены",
    "author": "И. Берард"
  }
]  
```

Данные от JSON-файла получаем асинхронно.  
Для этого используем `async/await` функцию:  

```js
async function getQuotes() {  
  const quotes = 'data.json';
  const res = await fetch(quotes);
  const data = await res.json(); 
  console.log(data);
}
getQuotes();
```

Ещё один способ работы с асинхронными данными - `fetch`

```js
function getQuotes() {
  const quotes = 'data.json';
  fetch(quotes)
    .then(res => res.json())
    .then(data => { 
      console.log(data);
    });
}
getQuotes();
```

Пример с `fetch` приводится для информации и сравнения. Для написания асинхронного кода `async/await` функции являются более удобными с точки зрения читабельности и форматирования кода.

Вместо JSON-файла с цитатами можно было создать js-объект с цитатами и работать с ним синхронно, но так как задача предложенного задания научиться писать асинхронный код, JSON-файл предпочтительнее.

## 6. Аудиоплеер

#### Добавление звука на веб-страницу.
С появлением HTML5 добавление аудиоплеера на страницу превратилось в рядовую задачу. Для этого достаточно в html-файл добавить код плеера, и в атрибуте `src` указать ссылку на аудио-файл.
```html
<audio src="" controls></audio>
```
[Пример 1 на codepen](https://codepen.io/irinainina/pen/poerqar)

Внешний вид встроенного в браузер аудиоплеера в разных браузерах выглядит немного по-разному и очень плохо стилизуется. Если нужно создать плеер с определённым дизайном, в приведённом выше коде необходимо убрать атрибут `controls`, который отвечает за отображение плеера и написать js-код для его проигрывания:
```js
const audio = document.querySelector('audio');
function playAudio() {
  audio.currentTime = 0;
  audio.play();
}
function pauseAudio() {
  audio.pause();
}
```
[Пример 2 на codepen](https://codepen.io/irinainina/pen/RwoKVBW)

Функции `playAudio()` и `pauseAudio()` достаточно простые. Первая запускает проигрывание плеера используя метод `play()`, вторая - останавливает проигрывание, используя метод `pause()`. Строка `audio.currentTime = 0` указывает, что аудиотрек при каждом запуске функции `playAudio()` будет проигрываться с начала.

Есть возможность создать плеер средствами JavaScript:
```js
const audio = new Audio();

function playAudio() {
  audio.src = // ссылка на аудио-файл;
  audio.currentTime = 0;
  audio.play();
}
```
[Пример 3 на codepen](https://codepen.io/irinainina/pen/dyvzrNV)

#### Объединение проигрывания и остановки звука в одной функции. Флаги
У большинства плееров используется одна кнопка для проигрывания и остановки воспроизведения. Если звука нет, клик по ней запускает проигрывание звука, если звук есть - останавливает. Это юзер-френдли - пользователю так удобнее. 

Чтобы реализовать такую возможность, нам необходимо объединить функции `playAudio()` и `pauseAudio()` в одну. Для создания такой функции нам прежде всего необходимо выяснить, играет ли в данный момент музыка. Для этого в глобальной области видимости, там, где находим элементы DOM и разместили переменную `randomNum`, создадим переменную `isPlay`.

Такие переменные, названия которых начинаются с `is`, называются флагами. Флаг может принимать только два значения: `true` или `false`. С помощью флагов проверяем наличие или отсутствие чего-либо. В данном случае проверяем проигрывание в данный момент звука.

Когда мы только открываем страницу, звука нет. Поэтому переменную `isPlay` создаём с значением `false`:
```js
let isPlay = false;
```
При клике по кнопке `Play audio` необходимо не только запустить проигрывание звука, но и изменить значение переменной, указав, что теперь `isPlay = true`.  
При клике по кнопке `Stop audio` останавливаем проигрывание звука и указываем, что `isPlay = false`.

Зная, когда у нас проигрывается звук, а когда нет, можем создать видоизменённую функцию `playAudio()` которая будет по-разному работать в зависимости от того, проигрывается ли в данный момент звук. Если звука нет `if(!isPlay)`, запускаем проигрывание, иначе - останавливаем. Такую функцию вам предстоит написать самостоятельно.

#### Объединение кнопок проигрывания и остановки звука в одну
Теперь, когда у нас есть одна функция, которая умеет и проигрывать, и останавливать звук, в плеере достаточно оставить только одну кнопку для запуска данной функции. Наша задача научиться менять внешний вид кнопки в зависимости от того, проигрывается в данный момент звук или нет.

Раньше, работая над слайдером, мы научились менять стиль элемента используя свойство `style`. Возможность изменения стиля элемента средствами JavaScript применяем только если нет других вариантов изменить стиль, например, если его значение получаем динамически в результате выполнения js-кода. Для всех остальных случаев используем JavaScript для добавления или удаления у элемента класса, для которого в css-коде прописан нужный стиль.

В css-коде создан класс `pause` для которого фоновым изображением указана иконка остановки звука. Для того, чтобы на кнопке проигрывания и остановки звука иконка проигрывания менялась на иконку остановки, нам необходимо добавлять кнопке класс `pause`, когда звук воспроизводится, и убирать, когда звука нет. Для этого используем метод `classList`.

#### Метод `classList`
Метод `classList` предназначен для работы с классами и поддерживается всеми современными браузерами:
- `element.classList.add('class');` - добавляет элементу класс;
- `element.classList.remove('class');` - удаляет класс;
- `element.classList.toggle('class');` - переключает класс: добавляет, если класса нет, и удаляет, если он есть.
- `element.classList.contains('class');` - проверяет, есть ли данный класс у элемента (возвращает `true` или `false`)

Обратите внимание. Так как метод `classList` работает только с классами, то в кавычках внутри может находиться только название класса. И вот перед этим названием класса **точка не ставится никогда**. Эту ошибку часто совершают начинающие разработчики.

Для изменения стиля кнопки при клике удобно использовать метод `classList.toggle();`
```js
function toggleBtn() {
  button.classList.toggle('pause');
}
button.addEventListener('click', toggleBtn);
```
[Пример на codepen](https://codepen.io/irinainina/pen/NWpwdMe)

Простая логика переключения класса при клике усложняется тем, что кроме кнопки `play` есть ещё кнопки `play-next` и `play-prev`, при клике по которым тоже воспроизводится музыка. Функцию для переключения класса `pause` пишем по той же логике, по которой написали видоизменённую функцию `playAudio()` - проверяем состояние флага `isPlay` и в зависимости от этого добавляем или удаляем у кнопки класс `pause` при помощи методов `classList.add()`, и `classList.remove()`

#### Треки можно пролистывать кликами по кнопкам
Функция пролистывания треков очень похожа на функцию пролистывания изображений, которую написали в процессе создания слайдера. Нам точно так же нужно создать глобальную переменную `playNum`. Присвоим ей значение `0`, так как вначале проигрывания воспроизводится первый трек. Создадим две функции `playNext()` и `playPrev()`, которые изменяют значение переменной `playNum`, увеличивая или уменьшая его. Внутри функций `playNext()` и `playPrev()` вызываем видоизменённую функцию `playAudio()`, которая будет проигрывать соответствующий трек. В следующем пункте рассмотрим как получить список треков для воспроизведения.

#### Создаём список воспроизведения. Модули в JavaScript
Было бы хорошо предусмотреть для пользователя возможность редактировать плейлист - добавлять в него новые треки, удалять старые. Но редактирование пользователем основного кода приложения не очень хорошая идея. Список треков нужно вынести в отдельный файл. Назовём его playList.js. Подключить такой файл можно непосредственно в index.html, и это будет работать. Но в какой-то момент у нас может оказаться несколько десятков файлов и нам всё равно придётся использовать модули. Попробуем это сделать уже сейчас. Нам необходимо подключить playList.js в index.js. Посмотрим, как это можно сделать.

Создадим файл playList.js
```js
const playList = [
  {      
    title: 'Aqua Caelestis',
    src: '../assets/sounds/Aqua Caelestis.mp3',
    duration: '00:58'
  },  
  {      
    title: 'River Flows In You',
    src: '../assets/sounds/River Flows In You.mp3',
    duration: '03:50'
  }
]
export default playList;
```
Последняя строчка в коде - экспорт по умолчанию. Такой экспорт в файле может быть только один.

Подключаем данный файл в `index.js`, в консоли можно увидеть результат подключения
```js
import playList from './playList.js';
console.log(playList);
```

Теперь, чтобы в функции `playAudio()` указать какой трек воспроизводить, вместо ссылки на трек достаточно указать его номер в плейлисте: 
```js
audio.src = playList[playNum].src;
```

Обратите внимание:
- при подключении в `index.html` js-файла с импортом, необходимо указать `type="module"`  
  `<script type="module" src="js/index.js"></script>`
- файл с импортом будет работать только на сервере. Live Server подходит.

#### Плейлист создаётся средствами JavaScript
Перед разработчиком часто возникает задача сгенерировать html-элементы средствами JavaScript. Как, например, в этом случае: так как пользователь может редактировать плейлист, мы не знаем заранее ни количество треков, ни их название. Список воспроизведения должен создаваться на основе данных, которые содержит экспортированный из файла `playList.js` массив `playList`.

Нам необходимо:
1. создать на странице элемент `li` - один из пунктов списка воспроизведения
2. добавить этому элементу класс 'play-item'
3. добавить этому элементу текстовое содержимое - название трека
4. добавить созданный элемент `li` в уже существующий на странице элемент `ul` с классом 'play-list'
5. Повторить указанную последовательность действий для всех элементов массива `playList`

Решение
1. создать элемент средствами js позволяет метод `createElement()`
```js
const li = document.createElement('li');
```
2. для добавления класса используем уже известный нам метод `classList.add()`
3. для добавления названия трека используем свойство `textContent`
4. для добавления элемента в другой элемент, который уже есть на странице, используем метод `append()`
```js
playListContainer.append(li)
```
4. Чтобы повторить указанную последовательность действий для каждого элемента массива `playList`, нужно перебрать все элементы массива. Самый простой и понятный начинающим способ - перебор элементов массива в цикле
```js
  for(let i = 0; i < playList.length; i++) {
    // здесь ваш код
  }
```
Более современный и удобный вариант - пройтись по массиву свойством `forEach`
```js
  playList.forEach(el => {
    // здесь ваш код
  })
```

#### Ключевые навыки, которые вы приобрели:
- добавление звука на страницу
- использование флагов
- метод `classList`
- модули в JavaScript
- создание элемента средствами JavaScript
- создали аудиоплеер

## 7. Продвинутый аудиоплеер

Принцип работы точно такой же, как при создании кастомного видеоплеера в задании Museum.DOM: верстаем аудиоплеер таким, каким он должен быть по вашему замыслу и при помощи js добавляем элементам плеера необходимую функциональность.

В создании кастомного аудиоплеера могут помочь материалы:
- Статья [Создание настраиваемого HTML5 Audio Player](https://webdesign.tutsplus.com/ru/tutorials/create-a-customized-html5-audio-player--webdesign-7081) (статья немного устарела, jQuery, который в ней используется, в проектах курса использовть запрещено)
- [Custom Audio Player](https://codepen.io/EmNudge/pen/rRbLJQ) на codepen - умение разбираться в чужом коде и преобразовать его под свои требования - ценный и полезный навык, а codepen - отличный источник такого кода
- [Simple Music Player](https://github.com/hecpolanco/Simple-Music-Player/blob/master/player.js) - [Demo](https://irinainina.github.io/Simple-Music-Player/player) - пример приведён потому, что в нём есть возможность переключения треков плейлиста, которой нет в предыдущем примере, и чтобы показать, что этот элемент может быть самостоятельным интересным приложением.

## 8. Перевод приложения

Перевод и локализация приложения - задачи, часто встречающиеся в разработке.  
Наиболее популярная библиотека для перевода - https://www.i18next.com/ - i18n – расшифровывается как интернационализация (internationalization). Это не просто библиотека, а целый фреймворк, имеющий интеграции со всеми популярными решениями, такими как Angular, React или Vue.js. 

Впрочем, библиотека не переводит текст сама, как можно было бы предположить из её названия. Библиотеке необходимо предоставить файлы с переводом всех фрагментов текста на странице, она лишь поможет при переключении языков подставить в указанное место нужный фрагмент.

Так как нам необходимо перевести только одну фразу - приветствие, подключать для этой цели библиотеку определённо излишне. 

Создайте объект `greetingTranslation`, укажите его ключами языки, на которое будет переводиться ваше приложение, в качестве значений укажите текст приветствия. Параметром функции, отображающей приветствие, укажите язык отображения страницы по умолчанию, в качестве свойства `textContent` указываем не текст, а значение объекта `greetingTranslation` с соответствующим текущему языку ключом. При переключении языка вызваем функцию ещё раз с соответствующим параметром. 

Для перевода описания погоды в функцию `getWeather()` в качестве параметра передаём язык отображения страницы и указываем его в шаблонной строке, содержащей ссылку, по которой получаем информацию о погоде: `https://api.openweathermap.org/data/2.5/weather?q=Минск&lang=ru&appid=08f2a575dda978b9c539199e54df03b0&units=metric`

Для перевода даты используем метод `toLocaleString()` с аргументом `options` в котором указываем язык отображения и формат даты. [Пример: использование аргумента options](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date/toLocaleString#example_using_options)

## 9. Получение фонового изображения от API

В ходе выполнения этого пункта требований вы научитесь работать с двумя популярными Images API: Unsplash API и Flickr API.

#### Unsplash API
- сайт: https://unsplash.com/developers
- документация: https://unsplash.com/documentation
- у данного сервиса есть лимит - 50 изображений в час
- регистрируемся на сайте
- подтверждаем email (переходим по ссылке, которая пришла на почту)
- создаём приложение `https://unsplash.com/oauth/applications`
- получаем Access Key
- генерируем ссылку:  
`https://api.unsplash.com/photos/random?orientation=landscape&query=nature&client_id=e2077ad31a806c894c460aec8f81bc2af4d09c4f8104ae3177bb809faf0eac17`  
В ней:  
  - `orientation=landscape` - фото вытянутое по горизонтали
  - `query=nature` - запрос, по которому ищем фото
  - `client_id=` - Access Key, у вас будет другой.

Для удобного просмотра результатов, которые возвращает API, установите расширение [JSONView](https://chrome.google.com/webstore/detail/jsonview/chklaanhfefbnpoihckbnefhakgolnmc?hl=ru)

Асинхронная функция, позволяющия получить ссылку на изображение в большом размере:

```js
 function getLinkToImage() {
 const url = 'https://api.unsplash.com/photos/random?query=morning&client_id=e2077ad31a806c894c460aec8f81bc2af4d09c4f8104ae3177bb809faf0eac17';
 fetch(url)
   .then(res => res.json())
   .then(data => {
     console.log(data.urls.regular)
   });
 }
 ```

 При повторном запуске функции фото будет другим.

 Самостоятельно перепишите функцию `getLinkToImage()` при помощи `async/await`.  
 Обратите внимание, что `async/await` функции работают только на сервере. Live Server (расширение VS Code) подойдёт.

<details>
  <summary>Проверьте полученный результат</summary>

  ```js
 async function getLinkToImage() {
   const url = 'https://api.unsplash.com/photos/random?query=morning&client_id=e2077ad31a806c894c460aec8f81bc2af4d09c4f8104ae3177bb809faf0eac17';
   const res = await fetch(url);
   const data = await res.json();
   console.log(data.urls.regular)
 }
  ```
</details>

---

#### Flickr API
- сайт: https://www.flickr.com/services/
- документация https://www.flickr.com/services/api/flickr.photos.search.html
- регистрируемся на сайте
- подтверждаем email (переходим по ссылке, которая пришла на почту)
- создаём приложение `https://www.flickr.com/services/apps/create/apply/`
- получаем API Key
- генерируем ссылку:  
`https://www.flickr.com/services/rest/?method=flickr.photos.search&api_key=0f15ff623f1198a1f7f52550f8c36057&tags=nature&extras=url_l&format=json&nojsoncallback=1`  
В ней:  
- `api_key=` - API Key, у вас будет другой.
- `tags=nature` - запрос, по которым ищем фото
- `extras=url_h` - возвращать только большие (large) фото.

Асинхронную функцию для получения ссылки на изображение вам предстоит написать самостоятельно.

Вы убедились, что алгоритм работы с различными API очень похож, научившись работать с одним из них, можно работать с любым другим.

## 10. Настройки приложения

Для работы с настройками удобно создать объект, в котором эти настройки указаны:

```js
const state = {
  language: 'en',
  photoSource: 'github',
  blocks: ['time', 'date','greeting', 'quote', 'weather', 'audio', 'todolist']
}
```

Создаём функции, которые отвечают за отображение страницы с соответствующими настройками, и при изменении настроек вызываем их.

Для плавного скрытия и отображения элементов используем css-свойство, для которого можно применить `transition` и при этом сохраняется зарезервированное за элементом место: `opacity` или `visibility`.

Свойство `display: none`, которое чаще всего используется для скрытия элемента, в данном случае не подходит: для него `transition` применить нельзя, т.е. плавное скрытие элемента с помощью этого свойства сделать не получится. 

Если по дизайну при скрытии элемента его место должен занять другой элемент, указываем для скрываемого элемента значения высоты или ширины равными 0. 

Не забудьте, что само появление и скрытие блока с настройками, тоже должно происходить плавно.